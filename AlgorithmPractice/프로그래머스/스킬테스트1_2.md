# 프로그래머스

Java 스킬테스트 1단계의 2번문제

***

과일 장수가 사과 상자를 포장하고 있습니다. 사과는 상태에 따라 1점부터 k점까지의 점수로 분류하며, k점이 최상품의 사과이고 1점이 최하품의 사과입니다. 사과 한 상자의 가격은 다음과 같이 결정됩니다.

한 상자에 사과를 m개씩 담아 포장합니다.
상자에 담긴 사과 중 가장 낮은 점수가 p (1 ≤ p ≤ k)점인 경우, 사과 한 상자의 가격은 p * m 입니다.
과일 장수가 가능한 많은 사과를 팔았을 때, 얻을 수 있는 최대 이익을 계산하고자 합니다.(사과는 상자 단위로만 판매하며, 남는 사과는 버립니다)

예를 들어, k = 3, m = 4, 사과 7개의 점수가 [1, 2, 3, 1, 2, 3, 1]이라면, 다음과 같이 [2, 3, 2, 3]으로 구성된 사과 상자 1개를 만들어 판매하여 최대 이익을 얻을 수 있습니다.

(최저 사과 점수) x (한 상자에 담긴 사과 개수) x (상자의 개수) = 2 x 4 x 1 = 8
사과의 최대 점수 k, 한 상자에 들어가는 사과의 수 m, 사과들의 점수 score가 주어졌을 때, 과일 장수가 얻을 수 있는 최대 이익을 return하는 solution 함수를 완성해주세요.

제한사항
3 ≤ k ≤ 9
3 ≤ m ≤ 10
7 ≤ score의 길이 ≤ 1,000,000
1 ≤ score[i] ≤ k
이익이 발생하지 않는 경우에는 0을 return 해주세요.
입출력 예
k	m	score	result
3	4	[1, 2, 3, 1, 2, 3, 1]	8
4	3	[4, 1, 2, 2, 4, 4, 4, 4, 1, 2, 4, 2]	33
입출력 예 설명
입출력 예 #1

문제의 예시와 같습니다.
입출력 예 #2

다음과 같이 사과 상자를 포장하여 모두 팔면 최대 이익을 낼 수 있습니다.
사과 상자	가격
[1, 1, 2]	1 x 3 = 3
[2, 2, 2]	2 x 3 = 6
[4, 4, 4]	4 x 3 = 12
[4, 4, 4]	4 x 3 = 12
따라서 (1 x 3 x 1) + (2 x 3 x 1) + (4 x 3 x 2) = 33을 return합니다.

```java
class Solution {
    public int solution(int k, int m, int[] score) {            
        int answer = 0;
        return answer;
    }
}
```

***

내가 생각한 의사코드

```java
        배열을 오름차순 정렬한다
        배열을 m으로 나눈다음 나머지만큼 반복을 패스한다
        사과의수 m만큼 잘라가며 점수를 구한다(첫번째 값 * m)

```

***

내가 구현한 코드(정답까지 도달하지 못함)

```java
import java.util.Scanner;
import java.util.Arrays;

class Solution {
    public int solution(int k, int m, int[] score) {              
        Arrays.sort(score);
        int n = score.length;
        int remainder = n % m;
       
        for (int i = remainder; 어떻게할지 생각이 안남) {
            int boxPrice = ?
            answer += boxPrice;
        }
        
        
        int answer = 0;
        return answer;
    }
}
```

***

ChatGpt풀이

- 사과 점수를 내림차순으로 정렬합니다. 이렇게 하면 가장 높은 점수의 사과들을 먼저 고려할 수 있습니다.
- 정렬된 리스트에서 m개씩 그룹을 만들어 최하 점수를 찾고 이익을 계산합니다.
- 남은 사과가 m개 미만이면 버립니다.

```java
import java.util.Arrays;

public class AppleBox {
    public int solution(int k, int m, int[] score) {
        Arrays.sort(score);
        
        int answer = 0;
        int n = score.length;
        
        // 내림차순으로 정렬된 score 배열에서 m개씩 그룹을 만들어 이익 계산
        for (int i = n - m; i >= 0; i -= m) {
            answer += score[i] * m;
        }
        
        return answer;
    }

}

```

***

### 회고

오랜만에 자바 알고리즘 풀이를 하느라 쉽지 않았다.

Arrays.sort 등도 어떻게 임포트해서 사용해야하는지 잘 기억나지 않았다.

내 의사코드에서 ‘m만큼 잘라가며 구한다’는 gpt의 ‘그룹을 만든다’와 비슷하므로 풀이 방향은 괜찮았다고 생각하지만,

배열에서 ‘그룹을 만든다’를 어떻게 구현할지 떠오르지 않았다

그리고 반복문의 시작지점인 i = n-m는 이해됐지만,

핵심 로직이라고 생각하는, i >= 0; i -= m가 쉽게 이해되지 않았다

결국 나는 배열을 앞에서부터 잘라가며 전진해야된다고 강하게 생각했던게 문제였나보다.

저 풀이 방법에서는 배열의 가장 끝 index - m부터 (그 그룹에서 제일 낮은값) * m을 한 뒤에,

그다음 m만큼 적은 index로 이동해(그 그룹에서 제일 낮은값) 다시 그 상자의 가격을 구하는 것이었다.

이 방법이 생각이 안났는데 의기소침하지 말고 계속 전진해야겠다