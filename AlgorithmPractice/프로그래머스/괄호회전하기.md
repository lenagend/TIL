다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.

- `()`, `[]`, `{}` 는 모두 올바른 괄호 문자열입니다.
- 만약 `A`가 올바른 괄호 문자열이라면, `(A)`, `[A]`, `{A}` 도 올바른 괄호 문자열입니다. 예를 들어, `[]` 가 올바른 괄호 문자열이므로, `([])` 도 올바른 괄호 문자열입니다.
- 만약 `A`, `B`가 올바른 괄호 문자열이라면, `AB` 도 올바른 괄호 문자열입니다. 예를 들어, `{}` 와 `([])` 가 올바른 괄호 문자열이므로, `{}([])` 도 올바른 괄호 문자열입니다.

대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 `s`가 매개변수로 주어집니다. 이 `s`를 왼쪽으로 x (*0 ≤ x < (`s`의 길이)*) 칸만큼 회전시켰을 때 `s`가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- s의 길이는 1 이상 1,000 이하입니다.

---

### 입출력 예

| s | result |
| --- | --- |
| `"[](){}"` | 3 |
| `"}]()[{"` | 2 |
| `"[)(]"` | 0 |
| `"}}}"` | 0 |

---

### 입출력 예 설명

**입출력 예 #1**

- 다음 표는 `"[](){}"` 를 회전시킨 모습을 나타낸 것입니다.

| x | s를 왼쪽으로 x칸만큼 회전 | 올바른 괄호 문자열? |
| --- | --- | --- |
| 0 | `"[](){}"` | O |
| 1 | `"](){}["` | X |
| 2 | `"(){}[]"` | O |
| 3 | `"){}[]("` | X |
| 4 | `"{}[]()"` | O |
| 5 | `"}[](){"` | X |
- 올바른 괄호 문자열이 되는 x가 3개이므로, 3을 return 해야 합니다.

**입출력 예 #2**

- 다음 표는 `"}]()[{"` 를 회전시킨 모습을 나타낸 것입니다.

| x | s를 왼쪽으로 x칸만큼 회전 | 올바른 괄호 문자열? |
| --- | --- | --- |
| 0 | `"}]()[{"` | X |
| 1 | `"]()[{}"` | X |
| 2 | `"()[{}]"` | O |
| 3 | `")[{}]("` | X |
| 4 | `"[{}]()"` | O |
| 5 | `"{}]()["` | X |
- 올바른 괄호 문자열이 되는 x가 2개이므로, 2를 return 해야 합니다.

**입출력 예 #3**

- s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.

**입출력 예 #4**

- s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.

---

### 의사코드

s =`"}]()[{"`

answer = 0

s의 길이만큼 반복문을 돌린다.

캐릭터 스택 stack을 선언한다

임시문자열 temp는 s로 선언한다

temp[0] substring으로 맨 뒤로 보낸다.

temp.길이만큼 반복해서 stack에 한글자씩 넣는다

(, {, [ 면 그냥 푸시한다

),},]이고 stack이 비어있으면 반복문 break

stack이 비어있지 않으면 스택을 pop 한다음,

각 괄호와 매치되는지 확인

매치 안되면 반복문 break

다 통과하면 answer ++

---

### 풀이(풀면서 디테일을 조금 변경했다. 의사코드를 더 치밀하게 짜야겠다)

```java
import java.util.*;

public class 괄호회전하기 {
    public static void main(String[] args) {
        괄호회전하기 q = new 괄호회전하기();
        String s = "[](){}";

        int result = q.solution(s);

        System.out.println(result);
    }
    public int solution(String s) {
        int answer = 0;

        String temp = s;

        for(int i = 0; i < s.length(); i++){
            Stack<Character> stack = new Stack<>();
            boolean isValid = true;  // 추가: 유효성을 확인하기 위한 플래그

            for(char c : temp.toCharArray()){
                if(c == '(' || c == '{' || c == '['){
                    stack.push(c);
                } else {
                    if(stack.isEmpty()){
                        isValid = false;
                        break;
                    } else {
                        char top = stack.pop();
                        if((c == ')' && top != '(') ||
                                (c == '}' && top != '{') ||
                                (c == ']' && top != '[')){
                            isValid = false;
                            break;
                        }
                    }
                }
            }

            // 스택이 비어있고 isValid가 true인 경우에만 정답으로 간주
            if(isValid && stack.isEmpty()){
                answer++;
            }

            // 문자열을 한 칸 회전
            temp = temp.substring(1) + temp.charAt(0);
        }

        return answer;
    }
}

```